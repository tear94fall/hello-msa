# 마이크로 서비스 아키텍쳐 여행기

## 1. 마이크로 서비스 아키텍쳐 여행 티켓

주니어 개발자로써 마이크로 서비스 아키텍쳐를 우연히 접할 기회가 있었습니다.  
마이크로 서비스 아키텍쳐 기반의 사이드 프로젝트를 진행하면서 겪었던 경험을 공유하고자 합니다.  
본 레포지토리가 마이크로 서비스 아키텍쳐에 익숙하지 않거나 공부중인 개발자에게는 좋은 자료가 되고,  
마이크로 서비스 아키텍쳐가 어느정도 익숙한 개발자에게는 리마인드를 위한 기회가 되었으면 좋겠습니다.  

## 2. 마이크로 서비스 아키텍쳐 여행자를 위한 가이드

마이크로 서비스 아키텍쳐를 구성하는 요소는 매우 다양합니다.  
본 레포지토리는 마이크로 서비스 아키텍쳐라는 큰 단위를 설명하고 있습니다.  
따라서 마이크로 서비스 아키텍쳐를 구성하는 상세한 개념과 하위 요소에 대한 설명은 생략되었습니다.  
예를 들어 Rest api가 무엇인지, 웹서버 동작 과정과 같은 상세한 개념은 다루지 않고 있습니다.  
이점 참고해주시면 감사하겠습니다. 그럼 이제 시작합니다!  

## 3. 마이크로 서비스 아키텍쳐 여정

여행의 시작입니다. 우선 어떻게 마이크로 서비스를 구성했는지 알아보기전에  
제가 처음으로 진행한 초기 프로젝트에 대한 내용에 대해 알아보도록 하겠습니다.   
모놀리식 아키텍쳐에서 마이크로 서비스 아키텍쳐 전환 과정을 이해하기 위해 기존 시스템을 알아보도록 합니다.   

- 초기 시스템 소개  
    - 모놀리식 아키텍쳐  
        - 단일 서버에 모놀리식 구조로 모든 인프라가 구성되어있음  
    - 발생했던 문제들  
        - 특정 기능 동작시 전체 기능이 복구 불가 상태가 되어 전체 서비스 이용 불가  
        - 스트레스 테스트 시에 서버가 다운되는 경우가 다반사였음  
            - 요청 특정 이상으로 처리시 에러 → 코드 리팩토링 → 요청 특정 이상으로 처리시 에러 → 코드 리팩토링 → (반복)  
    - 필요했던 조건들  
        - 도커 컨테이너 기반 일시적인 에러는 금방 복구 (사실상 서버 재시작)  
        - 심각한 문제 발생시에는 직접 복구 해주어야 했음 (무한 재시작으로 인해 복구 안하면 정상적인 서비스 제공 불가)  

두번쨰는 대망의 마이크로 서비스 아키텍쳐로의 전환입니다.   
첫번째에서 알아본 모놀리식 아키텍쳐를 마이크로 서비스 아키텍쳐로 전환하면서 겪었던 경험을 공유 합니다.  

- 마이크로 서비스 아키텍쳐 로의 전환  
    - 전환 하게된 이유  
        - 모놀리식 구조에서는 하나의 기능으로 인해 장애가 발생하는 경우 전체 시스템에 영향  
            - A 데이터 조회시 장애 발생시, B데이터 조회, C데이터 생성등 기타 다른 기능에 영향을 끼침  
        - 상대적으로 중요하지 않은 A데이터 조회 기능이 제대로 동작하지 않더라도, 중요한 기능인 B데이터 생성은 가능하도록한다.  
    - 전환 과정  
        - 디비 설계  
            - DDD를 통한 에그리게이션  
            - 도메인에 대한 이해  
                - 도메인 재설계  
            - 연관관계 분리  
                - 모놀리식 구조에서 사용하는 하나의 DB가 아닌 서로 다른 DB를 사용하는 경우도 고려  
                - 서비스가 분리 되고 서로 다른 DB를 사용하는 경우 연관관계 맵핑을 통한 데이터 CRUD 불가능  
                - 에그리게이션 단위로 묶이 데이터들은 연관관계를 사용  
                    - 분리된 서비스의 경우 필요에 따라 중복되는 데이터를 저장하는것도 가능  
                - 하나의 요청에 하위 요청을 통한 데이터 조립을 통한 완성된 데이터 응답  
                    - 하나의 서비스에 장애가 생긴다고 하더라도 기타 데이터를 전달할수있음  
                        - 하단의 서킷 브레이커 내용에서 다시 언급  
        - 서비스의 분할  
            - 무엇부터 분할할것인가?  
                - 가장 중요도가 낮은 서비스 부터 분리 시작  
                - 가장 중요한 서비스 전화시 메인 서비스를 일시적으로 이용할수 없음  
                - 동일 포트 동일한 url 을 사용하도록 구성  
                    - 클라이언트 코드가 같이 변경되어 베포 되어야하는데, 만약 이미 베포된 상태라면 이걸 막을 방법이 없었음  
                    - 포트 변경 및 url 변경시 모두 클라이언트는 에러를 발생하며, 서비스가 안되었을 상황  
        - Api gateway의 도입  
            - 인증 문제 발생  
                - 세션 문제로 인한 문제  
                    - 모든 서비스에서 세션 인증을 할수없음  
                        - MSA에서는 하나의 클라이언트가 다수의 서비스와 통신하기 때문  
                            - 만일 인증이 변경되는 경우 변경 내용을 서비스 모두에 반영해야했음  
                    - 세션 탈취로 인한 가능성  
                        - 인증 방식 변경 필요  
                    - 로그아웃시 모든 인증에 대해서 만료 처리를 해야하는데, 서비스 갯수만큼 처리해야함  
                        - N-1개에는 인증 만료 처리가 완료되었으나, 1개의 서비스에 인증 만료 처리가 안된경우  
                        - 실제 로그아웃동작을 수행하였으나, 일부 요청은 정상 요청이 가능하는 경우가 발생함  
                - 모든 서비스에 인증 기능을 추가 할순 없음  
                    - 변경되는 내용이 생기는 경우 모두에 반영해야했음  
            - 모든 인증은 가장 앞단에 있는 api gateway에서 수행  
                - 클라이언트로 부터 들어오는 모든 요청은 api gateway를 거친다.  
                - 클라이언트는 내부의 서비스의 포트를 몰라도되고, 오직 api gateway의 정보만 알고있으면 된다.  
                    - 내부에서 구동되는 서비스의 포트나 정보를 외부에 노출하지 않아도된다.  
            - 인증 방식의 변경  
                - JWT 토큰을 이용한 인증 방식   
                    - access-toekn 과 refresh-token을 이용한 인증  
                    - 만일 토큰이 탈취 당하더라도, 짧은 주기를 통해 만료시 재발급 받도록 한다.  
                        - 만료시 refresh-token을 통해 access-token을 재발급 받는다.  
                    - refresh-token또한 탈취 우려가 있으나, 로그인 시에만 재발급 한다.  
                    - 토큰은 상대적으로 접근이 빠른 redis 를 이용한다.  
            - 로드 밸런싱  
                - MSA는 갑작스러운 트래픽에 대응하기 위해 다수의 서비스를 구동하기도 한다.  
                    - 각각의 서비스는 동일한 기능을 수행하지만 서로 다른 포트를 가지고 있다.   
                    - 만일 회원 서비스가 4개가 구동중인데, 한개의 서비스에만 요청을 보내면 또다른 병목 현상이 발생한다.   
                - api gateway는 로드 밸런싱 기능을 지원한다.  
                    - 하지만 api gateway로 요청이 도달했다고 해도, 내부 서비스들에 접근하려면 각각의 서비스들의 정보를 알아야한다.  
                    - 이것은 다음의 디스커버리 서비스 도입을 통해 해결한다.  
        - 디스커버리 서비스 도입  
            - MSA는 특성상 요청하나가 발생하면 하위에 여러 요청이 추가로 발생한다.  
                - 앞서 api gateway를 통해 클라이언트에서 오는 모든 요청은 api gateway를 거친다.  
                    - 하지만 문제는 클라이언트로 부터 오는 요청을 처리하기 위해 발생하는 서비스간의 내부 요청  
                - 서비스들은 통신하려는 서비스의 정보를 모두 알고있어야한다.  
                    - 만일 트래픽 증가로 인해, 서비스를 증가하는 경우 이모든 정보를 갱신해야한다.  
                - 서비스들의 정보를 관리하고, 서비스의 정보를 알려주는 서비스가 필요했다.  
                    - 디스커버리 패턴은 하위의 모든 서비스들에 대한 정보를 가지고 있으며, 필요시 이를 전달해주는 역할을 한다.  
                - 모든 서비스들은 구동되면서 자신의 정보를 디스커버리 서비스에 전달한다.  
                    - 디스커버리 서비스들은 동일한 서비스를 구분한다.  
                - 디스커버리 서비스와 api gateway의 조합  
                    - 클라이언트로 부터 들어오는 요청을 받은 api gateway는 서비스를 구분하고, 해당되는 서비스로 로드밸런싱 기능을 수행한다.  
                        - 다수의 로그인 요청이 오는 경우 로그인 서비스에게 라운드 로빈방식으로 요청을 로드 밸런싱 수행  
        - 설정 정보 관리  
            - 서비스마다 공통되는 설정도 존재하고, 개별 설정도 존재한다.  
                - 개별 설정의 경우 해당 서비스에서만 필요로 하므로 공통화 필요성 낮음  
            - 다만 공통되는 설정의 경우 변경시 모든 서비스를 변경 해주어야한다.  
            - 디스커버리 서비스처럼 설정 정보를 관리하는 서비스의 필요  
                - 설정 정보 변경시 서비스들에 전파(브로드 캐스팅)하는 기능 지원  
            - 설정 정보를 관리 저장소 필요 (깃허브 private repository), 설정 변경시 이를 감지하고 설정 갱신을 하도록 서비스들에게 전파 기능 지원  
        - 메시지 브로커를 통한 대용량 트래픽 처리  
            - 기존의 redis pub/sub 기능 개선  
            - redis의 pub/sub 기능의 단점  
                - 서비스가 기작되는 시점에 휘발성으로 인해 채널을 통해 데이터를 전달 받지 못하는 경우 발생  
                - 서비스가 재시작  
            - 보다 안정적이고 성능이 좋은 RabbitMQ를 사용  
                - RabbitMQ의 pub/sub 기능을 이용해 휘발성 문제를 해결  
                - Redis Streaming 검토도 고려했으나 최종적으로는 RabbitMQ 사용  
                    - Redis 보다 높은 성능 기대로 인한 선택  
        - 서킷 브레이커를 통한 장애 전파 방지  
            - 서킷 브레이커를 통해 내부 통신 중간단계에서 발생하는 실패에 대해 전체 과정이 실패하지 않도록한다.  
                - 서킷 브레이커를 통해 요청에 대한 실패시 재시도, 장애 발생에 대한 설정을 통해 해당 조건이 맞아 떨어지는 경우 장애로 감지  
                - 장애 발생으로 감지된 경우 장애 전파를 차단하기 위해, 미리 정해진 동작을 수행하도록 한다.  
                    - 재시도 3회 혹은 timeout 발생시 빈데이터를 전달 하도록 설정  
                    - 리뷰 서비스에서 리뷰 조회시 리뷰 별점등은 제대로 조회가 불가능 하더라도 내용은 정상적으로 보이게 해야하는 경우  
                        - 별점 조회 요청 장애시 별점을 0개로 전달하고, 리뷰 내용이나 제목등과 같은 데이터는 정상 전달 하도록 한다.  
        - 마이크로 서비스 환경에서 로그 추적   
            - 마이크로 서비스 특성상 서로 다른 서비스로 요청이 연이어 발생하는 경우가 있음  
            - 장애 발생시 각각의 서비스의 로그를 취합하기 매우 어려우며, 장애 시점을 찾는것 또한 쉽지 않음  
            - 장애 지점 모니터링 및 분상 환경에서의 로그 추적을 위한 zipkin 도입  
                - 요청별 트랜젝션을 통한 분산 환경에서의 로그 추적 및 장애 시점 모니터링 가능  
                - zipkin의 경우 스토리지를 DB 또는 ELK 스택 으로도 구성가능하며, 해당 저장소를 통해 장애에 대한 분석이 가능하다.  
                    - 특정 요청 구간에서 장애가 발생하는 문제, 특정 서비스에서 트래픽 증가로 레이턴시가 길어지는 문제 등   
                    - 시각화를 위해 그라나파랑 연동하는 경우도 있는데, 해당 부분은 반영 검토중   
                    - 현재는 서비스 운영을 하고 있지않아, 백오피스가 없다.  
                        - 서비스를 운영하는 입장이라면, 백오피스가 필요한데, 이때 요긴하게 사용할을 수 있을것같다.  
        - 확장 가능한 스토리지  
            - 로컬 디스크에 저장하는 경우 스케일 아웃이 어려운 경우가 발생  
            - 이를 해결하기 위해서 비즈니스 로직이 변경되는 경우가 발생할 수 있음  
            - AWS에서 지원하는 확장이 용이한 S3 스토리지와 호환되는 minio 선택  
                - minio는 멀티 노드를 지원하여, 한개의 노드에 장애가 발생해도 정상적으로 데이터 운영이 가능하다.  


세번째는 마이크로 서비스 아키텍쳐 전환 이후 겪었던 문제들 입니다.  

- MSA 전환 이후의 문제  
    - MSA에서는 모놀리식 구조와는 다르게 서로 다른 DB를 사용할 수 있습니다.  
        - 서비스도 분리되는 경우 연관관계를 이용할수 없게 됩니다.
        - [MSA에서 서비스 분리에 따른 데이터 연관관계 해결 및 팁](./README-DATA-RELATION.md)
    - 추가되는 요구사항
        - 서비스 전환 이후에도 추가적인 요구 사항은 발생하게 됩니다.
        - [MSA 전환 이후 기능 추가하기](./README-NEW-FEATURE.md)

마지막은 마이크로 서비스 아키텍쳐 전환간 미처 진행하지 못하거나 중단되었던 내용입니다.  
이는 또한 제가 앞으로 해결해야할 숙제이기도 합니다.  

- 아쉬운점   
    - 테스트의 부족  
        - 유닛 테스트 단위에서 부족헀던점   
            - 모놀리식 환경의 경우 대부분의 테스트 코드를 작성하였다.  
                - 모놀리식 환경이므로 테스트 환경이 크게 복잡하지 않았다.  
            - MSA에서는 하나의 요청에대해 내부에서 다수의 요청이 발생하는데, 이런 부분을 mocking 화 하여 테스트 계획중  
                - Mocking 작업을 하는데에만 꽤나 많은 시간이 들어갈것같았고, 비즈니스 로직을 짜기에도 바빳다.  
        - 테스트 단위  
            - MSA 에서는 하나의 요청에 대해 내부적으로 다수의 요청이 같이 발생한다.  
                - 따라서 시나리오 기반의 테스트를 구성하였고, Postman Collection을 통해 시나리오를 구성 & 테스트하였다.   
            - 웹 소켓 테스트 환경  
                - 이것도 Postman 으로 테스트가 가능하긴 했다. (9.x 번대 버전에 임시로 들어갔다가 10.x 버전부터 정식 지원)  
                - postman으로만 테스트 하다가 코드 작성하여, test용 클라이언트를 개발하였다.  
                - 최근에는 이것도 유닛 테스트가 가능하다는 블로그 글을 보아, 반영 예정  
    - aws 환경으로 이전  
        - 이전 환경은 도커 컴포즈를 이용한 도커 컨테이너 환경  
            - 로컬 환경에서 테스트, 실제 서비스를 운영하기 위해서는 클라우드 환경이 반드시 필요하였음  
        - aws 환경으로 이전 하는 경우 프리 티어 혹은 small티어로는 프로젝트 정상 기동 불가 (메모리 부족)  
            - 프리 티어는 메모리가 2GB밖에 제공되지 않음  
            - 도커만 설치후 젠킨스만 구동해도 메모리가 부족한 현상이 발생  
        - 로컬에서 도커 컨테이너 10개 이상을 띄우는 경우 최소 16GB 정도의 메모리가 확보가 되어야함  
        - 스토리지에 관해서도 적어도 100GB이상은 필요했음 것으로 보임  
            - 프리티어는 약 20GB정도의 스토리지를 제공했던 것으로 기억함  
        - 사이드 프로젝트로 지출 되는 비용이 만만치 않으므로 이전 중단   
    - EKS 환경으로 이전  
        - 도커 컨테이너 기반으로 개발되어, 쿠버네티스로의 일부 이전은 크게 어렵지 않았음  
        - 멀티 클러스터 기반으로 설계 되어있지 않아, 이를 개선하기 위해서는 상당수의 코드 + 인프라 설정이 변경되어야 했음  
        - 쿠버네티스에서 사용하는 각종 설정 및 구성에 대한 학습으로 인해 바로 이전은 어려웠음, 따라서 후에 이전하는 방법을 고려  
            - 설정과 관련된 경우 configMap을 통해 따로 설정을 관리하는 서비스를 두지 않아도 되는데, 변경시 코드상당수가 변경되어야함


## 여행 후기

이제 마이크로 서비스 아키텍쳐로의 여행이 끝났습니다. 즐거운 여행 되셨나요?  
다음에 또 좋은 여행으로 찾아뵙겠습니다.   
